export type Tile=string; export type PlayerHand=Tile[]; export type Wall=Tile[];
export interface PlayerState{ ai:string; hand:PlayerHand; discards:Tile[]; score:number; ronWins?:number; zimoWins?:number; dealInCount?:number; lastWinScore?:number; melds?:{type:'CHI'|'PON'|'KAN';tiles:Tile[]}[]; }
export const generateWall=():Wall=>{ const t:Tile[]=[]; for(const s of ['W','B','T']) for(let i=1;i<=9;i++) for(let k=0;k<4;k++) t.push(`${i}${s}`); for(let i=1;i<=7;i++) for(let k=0;k<4;k++) t.push(`${i}Z`); return shuffle(t); };
export const shuffle=<T,>(arr:T[])=>{ const a=[...arr]; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j]];} return a; };
export const dealHands=(w:Wall, players:string[], n=13):PlayerState[]=> players.map(ai=>({ ai, hand:w.splice(0,n), discards:[], score:1000, melds:[] }));
export const drawTile=(w:Wall):Tile|null=> w.length? w.shift()!:null;
export function checkWin(hand:Tile[]):{win:boolean;fan:string[];score:number}{ if(hand.length!==14) return {win:false,fan:[],score:0}; const c:Record<string,number>={}; for(const t of hand) c[t]=(c[t]||0)+1; if(isThirteenOrphans(hand)) return {win:true,fan:['国士无双'],score:88}; if(isSevenPairs(c)) return {win:true,fan:['七对'],score:24}; const tiles=Object.keys(c).sort(); for(const pair of tiles){ if((c[pair]||0)<2) continue; const cc={...c}; cc[pair]-=2; if(canFormMelds(cc)) return {win:true,fan:['平胡'],score:8}; } return {win:false,fan:[],score:0}; }
function canFormMelds(c:Record<string,number>):boolean{ const tiles=Object.keys(c).filter(t=>c[t]>0).sort(); for(const tile of tiles){ while(c[tile]>0){ if(c[tile]>=3){ c[tile]-=3; continue;} const n=parseInt(tile[0]); const s=tile[1]; if(s==='Z') return false; const t2=`${n+1}${s}`, t3=`${n+2}${s}`; if((c[t2]||0)>0 && (c[t3]||0)>0){ c[tile]--; c[t2]--; c[t3]--; } else return false; } } return true; }
function isSevenPairs(c:Record<string,number>){ return Object.values(c).filter(v=>v===2).length===7; }
function isThirteenOrphans(hand:Tile[]){ const req=['1W','9W','1B','9B','1T','9T','1Z','2Z','3Z','4Z','5Z','6Z','7Z']; const set=new Set(hand); return req.every(t=>set.has(t)) && hand.some(t=> hand.filter(x=>x===t).length===2); }
export const checkTing=(hand:Tile[])=>{ const all:Tile[]=[]; ['W','B','T'].forEach(s=>{ for(let i=1;i<=9;i++) all.push(`${i}${s}`); }); for(let i=1;i<=7;i++) all.push(`${i}Z`); const r:Tile[]=[]; for(const t of all){ const temp=[...hand,t]; if(checkWin(temp).win) r.push(t);} return r; };
export function updateScores(ps:PlayerState[], wIdx:number, base:number, type:'ZIMO'|'RON', fromIdx?:number){ const np=ps.map(p=>({...p})); if(type==='ZIMO'){ const losers=np.filter((_,i)=>i!==wIdx); const gain=base*losers.length; np[wIdx].score+=gain; np[wIdx].zimoWins=(np[wIdx].zimoWins||0)+1; np[wIdx].lastWinScore=gain; losers.forEach((p)=>{ const idx=ps.indexOf(p); np[idx].score-=base; np[idx].dealInCount=(np[idx].dealInCount||0)+1; }); } else { if(fromIdx==null) return np; np[wIdx].score+=base; np[wIdx].ronWins=(np[wIdx].ronWins||0)+1; np[wIdx].lastWinScore=base; np[fromIdx].score-=base; np[fromIdx].dealInCount=(np[fromIdx].dealInCount||0)+1; } return np; }
